
écris moi un code pour un algorithme de trading automatique sur Tradingview qui va utiliser la classification de LORENTZIAN
en combinant les 7 dimensions suivantes :
1) Liquidité
2) Prix
3) Volume
4) Temps
5) Momentum
6) Volatilité
7) Valeur


VAR CurrUser = USERPRINCIPALNAME()

VAR PTFListGAD =
    CALCULATETABLE (
        VALUES ( a2posecuriteagent ),
        FILTER ( ALLSELECTED ( a2posecuriteagent ), [EMAIL_GAD] = CurrUser )
    )

VAR PTFListAXA =
    CALCULATETABLE (
        VALUES ( a2posecuriteagent[PTF_ID] ),
        FILTER ( ALLSELECTED ( a2posecuriteagent ), [EMAIL_AXA] = CurrUser )
    )

VAR PTFList = UNION (PTFListGAD,PTFListAXA)
 
 return
[EMAIL_GAD] = USERPRINCIPALNAME() || [EMAIL_AXA] = USERPRINCIPALNAME()


En tant qu'expert en power bi et en RLS, je veux que tu m'aides à développer les bonnes RLS pour le modèle suivant ;

Table transactionnelle :bv_a2p qui contient les colonnes suivantes : annee, numéro_contrat, etc...
d'autres tables dimentionnelles comme calendrier, dim_contrat, etc... comme tu peux le voir sur le schéma

j'ai des tables RLS :
 DIM_AGENT qui a une relation de 1 à n avec la table a2posecuriteagent ( qui contient les données importantes EMAIl_GAD,ID_PTF (identifiant portefeuille))

a2posecuriteagent qui filtre securite_contrat de * à * via la clé identifiant portefeuille ( car un contrat peut être par plusieurs agents..)
a2posecuriteagent qui filtre en double directionnel la table DIM_PORTEFEUILLE (* à 1)  : j'ai mis la dim_portefeuille pour pouvoir mettre un filtre portfeuille sur mon rapport de manière à ce que les agents ne puissent filtrer que sur leurs portfeuilles


securite_contrat filtre 1 à * la table transactionnelle bv_a2p via la clé numéro_contrat

securite_contrat  filtre aussi dim_client en bidirectionnel entre de * à 1 via la clé personne afin d'avoir par la suite un filtre Client pour que l'agent filtre ses client



Mais le problème c'est que les RLS ne fonctionnent pas quand je les parametre (voir l'image)
############################################################################################################
#######################################################################################################################

Sachant que la colonne montant_mouvement, est de type nombre décimal 
j'aimerais que les mesures suivantes m'affichent des nombres entiers complets au lieu d'afficher des nombres comme 35K , je veux 35767 eur (avec signe euros)
il faut aussi tenir compte  qu'il y a une mesure qui est la somme des deux autres que tu verras dans le dax code donc à à prendre en compte pour la stratégie globale

1 ere mesure (nom fonctionnel Encours) :
PM_FIN_ANNEE_FILTER = 

VAR HasYearFilter   = ISFILTERED ( 'Calendrier'[Année] )

VAR TodayDate       = [Endate]

VAR StartDefault    = [Startdate]

/* 1) Dernière date de 'PM FIN ANNEE' selon le mode */

VAR LastPMDate =

  
        CALCULATE (

            MAX ( 'bv_a2p'[date_de_valorisation] ),

            KEEPFILTERS ( 'bv_a2p'[type_mouvement] = "PM FIN ANNEE" )

        )

/* 2) Somme des seules PM de cette dernière date */

RETURN

IF (

    NOT ISBLANK ( LastPMDate ),

    CALCULATE (

        SUM ( 'bv_a2p'[montant_mouvement] ),

        'bv_a2p'[type_mouvement] = "PM FIN ANNEE",

        'bv_a2p'[date_de_valorisation] = LastPMDate

    )

)

2ème mesure (nom fonctionnel : Versements nets)
TOTAL_VERSEMENTS_FILTER = 

VAR StartDate     = DATE([Startdate],1,1)
VAR EndDate     = DATE ([Endate],12,31 )

VAR Result = 
-SUMX ( 
    FILTER('bv_a2p',
    ('bv_a2p'[montant_mouvement] < 0 
    && bv_a2p[type_mouvement] = "VERSEMENT" 
    && bv_a2p[date_de_valorisation] >= StartDate 
    && bv_a2p[date_de_valorisation] <= EndDate )
    ) , 'bv_a2p'[montant_mouvement] )
RETURN 
IF(Result == BLANK(), 0,Result)
3ème mesure (Rachats brut)
TOTAL_RETRAIT_FILTER = 
VAR StartDate     = DATE([Startdate],1,1)
VAR EndDate     = DATE ([Endate],12,31 )


VAR  RESULT = SUMX (
     FILTER('bv_a2p',
      'bv_a2p'[montant_mouvement] > 0
      && bv_a2p[type_mouvement] = "RACHAT" && 
      'bv_a2p'[date_de_valorisation] >= StartDate &&
       'bv_a2p'[date_de_valorisation] <= EndDate),
      'bv_a2p'[montant_mouvement])
RETURN
IF (RESULT ==BLANK(), 0, RESULT)

4ème mesure (somme des deux autres, nom somme des mouvements
[TOTAL_VERSEMENTS_FILTER] - [TOTAL_RETRAIT_FILTER]


 




