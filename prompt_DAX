
//@version=5
strategy("Lorentzian 7D Classifier (Liquidity, Price, Volume, Time, Momentum, Volatility, Value)",
     overlay=true, initial_capital=100000, commission_type=strategy.commission.percent, commission_value=0.01, pyramiding=0, calc_on_order_fills=true, calc_on_every_tick=true)

// =============== INPUTS ===============
lenEMA      = input.int(50, "EMA (Price/Value)", minval=2)
lenVWAP     = input.bool(true, "Use Session VWAP for Value? (else EMA slow)")
lenVolSMA   = input.int(50, "Volume SMA", minval=5)
lenATR      = input.int(14, "ATR length", minval=1)
lenROC      = input.int(12, "Momentum ROC length", minval=1)
liqLookback = input.int(50, "Liquidity (Amihud) lookback (zscore base)", minval=20)
zLookback   = input.int(100, "Z-Score baseline window", minval=30)
useSession  = input.string("FX/Indices", "Time Regime Template", options=["FX/Indices", "Crypto", "US Stocks"])

w_time      = input.float(1.0, "Weight: Time (t)", step=0.1)
w_liq       = input.float(1.0, "Weight: Liquidity", step=0.1)
w_price     = input.float(1.0, "Weight: Price", step=0.1)
w_volume    = input.float(1.0, "Weight: Volume", step=0.1)
w_mom       = input.float(1.0, "Weight: Momentum", step=0.1)
w_vola      = input.float(1.0, "Weight: Volatility", step=0.1)
w_value     = input.float(1.0, "Weight: Value", step=0.1)

L_trend_th  = input.float(0.75, "Lorentzian threshold: Trend regime", step=0.05)
L_revert_th = input.float(-0.75, "Lorentzian threshold: Mean-revert regime", step=0.05)

riskATR     = input.float(2.0, "Stop ATR multiple", step=0.1)
tpATR       = input.float(3.0, "Take-profit ATR multiple", step=0.1)
maxPosBars  = input.int(400, "Max bars in trade", minval=1)

// =============== HELPERS ===============
var float na_safe = na

zscore(src, lb) =>
    m = ta.sma(src, lb)
    s = ta.stdev(src, lb)
    s > 0 ? (src - m) / s : 0.0

// Return in decimal
ret = math.log(close) - math.log(close[1])

dollarVol = volume * hlc3
amihud = nz(math.abs(ret) / math.max(dollarVol, 1e-9))                          // illiquidity
liq_raw = 1.0 / (1e-9 + amihud)                                                 // higher => more liquid
liqN = zscore(liq_raw, liqLookback)

// PRICE: deviation to EMA
emaP = ta.ema(close, lenEMA)
priceN = zscore((close - emaP) / emaP, zLookback)

// VOLUME: zscore
volN = zscore(volume, lenVolSMA)

// TIME: session activity score 0..1 (heuristics by market)
hour  = timenow ? hour : hour
sessScore = switch useSession
    "FX/Indices" => (hour >= 7 and hour <= 10 ? 0.8 : 0) + (hour >= 13 and hour <= 16 ? 1.0 : 0) + (hour >= 17 and hour <= 19 ? 0.6 : 0)
    "Crypto"     => (hour >= 0 and hour <= 2 ? 0.4 : 0) + (hour >= 7 and hour <= 10 ? 0.6 : 0) + (hour >= 13 and hour <= 17 ? 1.0 : 0)
    "US Stocks"  => (hour >= 13 and hour <= 20 ? 1.0 : 0) // cash hours approx UTC
tN = math.min(1.0, sessScore)

// MOMENTUM: ROC normalized
roc = ta.roc(close, lenROC)
momN = zscore(roc, zLookback)

// VOLATILITY: ATR/close zscore
atr = ta.atr(lenATR)
volaN = zscore(atr / close, zLookback)

// VALUE: deviation to VWAP (session) or slow EMA
vwapPrice = ta.vwap(close)
valueBase = lenVWAP ? vwapPrice : ta.ema(close, lenEMA * 2)
valueN = zscore((close - valueBase) / valueBase, zLookback)

// =============== LORENTZIAN CLASSIFIER ===============
// Build weighted components
t_comp   = w_time  * tN
liq_comp = w_liq   * liqN
p_comp   = w_price * priceN
v_comp   = w_volume* volN
m_comp   = w_mom   * momN
vo_comp  = w_vola  * volaN
val_comp = w_value * valueN

// Lorentzian score: L = t^2 - sum(space-like)^2
L = math.pow(t_comp, 2) - (math.pow(liq_comp, 2) + math.pow(p_comp, 2) + math.pow(v_comp, 2) + math.pow(m_comp, 2) + math.pow(vo_comp, 2) + math.pow(val_comp, 2))

// Regime labels
isTrend  = L > L_trend_th
isRevert = L < L_revert_th
isNeutral= not isTrend and not isRevert

// =============== ENTRY/EXIT LOGIC ===============
// Additional sanity filters for entries
bullFilter = momN > 0 and priceN > -0.25 and liqN > -0.5
bearFilter = momN < 0 and priceN <  0.25 and liqN > -0.5

// Trend regime entries: follow momentum & breakouts
longTrig  = isTrend and bullFilter and close > ta.highest(high, 5)[1]
shortTrig = isTrend and bearFilter and close < ta.lowest(low, 5)[1]

// Mean-revert regime entries: fade extremes vs value/VWAP
mr_long  = isRevert and valueN < -1.0 and momN > -0.5
mr_short = isRevert and valueN >  1.0 and momN <  0.5

// Choose which signal dominates (priority: trend > mean-revert)
enterLong  = longTrig or (not longTrig and not shortTrig and mr_long)
enterShort = shortTrig or (not longTrig and not shortTrig and mr_short)

// Risk management (ATR based)
longSL  = close - riskATR * atr
longTP  = close + tpATR   * atr
shortSL = close + riskATR * atr
shortTP = close - tpATR   * atr

// Avoid conflicting positions
if enterLong and strategy.position_size <= 0
    strategy.entry("Long", strategy.long)
if enterShort and strategy.position_size >= 0
    strategy.entry("Short", strategy.short)

// Exits
strategy.exit("L-Exit", from_entry="Long",  stop=longSL,  limit=longTP)
strategy.exit("S-Exit", from_entry="Short", stop=shortSL, limit=shortTP)

// Time stop
if strategy.position_size != 0
    var int barsInPos = 0
    barsInPos += 1
    if barsInPos >= maxPosBars
        strategy.close(id=strategy.position_size > 0 ? "Long" : "Short", comment="TimeStop")
else
    barsInPos := 0

// =============== PLOTTING ===============
plot(emaP, "EMA", display=display.none)
plot(vwapPrice, "VWAP", color=color.new(color.gray, 60))

plot(L, "Lorentzian L", color = L >= 0 ? color.new(color.lime, 0) : color.new(color.red, 0), linewidth=2, display=display.bottom)
hline(L_trend_th,  "L Trend Th",  color=color.new(color.lime, 60))
hline(L_revert_th, "L Revert Th", color=color.new(color.red, 60))
bgcolor(isTrend ? color.new(color.lime, 90) : isRevert ? color.new(color.red, 90) : color.new(color.gray, 95))

// Debug table
var table t = table.new(position.top_right, 1, 9, border_width=1)
if barstate.islast
    table.cell(t, 0, 0, "L="+str.tostring(L, format.mintick))
    table.cell(t, 0, 1, "tN="+str.tostring(tN, format.mintick))
    table.cell(t, 0, 2, "liqN="+str.tostring(liqN, format.mintick))
    table.cell(t, 0, 3, "priceN="+str.tostring(priceN, format.mintick))
    table.cell(t, 0, 4, "volN="+str.tostring(volN, format.mintick))
    table.cell(t, 0, 5, "momN="+str.tostring(momN, format.mintick))
    table.cell(t, 0, 6, "volaN="+str.tostring(volaN, format.mintick))
    table.cell(t, 0, 7, "valueN="+str.tostring(valueN, format.mintick))
    regime = isTrend ? "TREND" : isRevert ? "MEAN-REVERT" : "NEUTRE"
    table.cell(t, 0, 8, "Regime: " + regime)








-- TRI % sur 10 ans (fenêtre glissante depuis 01/01/(année courante - 9) jusqu’à aujourd’hui)
TRI %_10ans (fast) :=
VAR _today  = TODAY()
VAR _start  = DATE( YEAR(_today) - 9, 1, 1 )
RETURN
CALCULATE(
    XIRR( 'bv_a2p', 'bv_a2p'[montant_mouvement], 'bv_a2p'[date_de_valorisation], , BLANK() ),
    REMOVEFILTERS( 'Calendrier' ),
    'bv_a2p'[date_de_valorisation] >= _start,
    'bv_a2p'[date_de_valorisation] <= _today
)

Rang TRI 10 ans :=
RANKX(
    ALL( DimContrat[NumContrat] ),
    [TRI %_10ans (fast)],
    ,
    DESC,
    DENSE
)

TRI % Top5 (10 ans) :=
VAR _tri = [TRI %_10ans (fast)]
VAR _rk  = [Rang TRI 10 ans]
RETURN IF( NOT ISBLANK(_tri) && _rk <= 5, _tri )



###############################
TRI %_5ans = 
VAR _cy     = YEAR ( TODAY() )
VAR _start  = DATE ( _cy - 4, 1, 1 )
VAR _end    = DATE ( _cy,     12, 31 )
RETURN
CALCULATE (
   XIRR (
       'bv_a2p',
       'bv_a2p'[montant_mouvement],
       'bv_a2p'[date_de_valorisation],,BLANK()
   ),
   REMOVEFILTERS ( 'Calendrier'[Date] ),
   DATESBETWEEN ( 'Calendrier'[Date], _start, _end )
)
#######################################

Total versement (fast) :=
CALCULATE (
    - SUM ( 'bv_a2p'[montant_mouvement] ),
    KEEPFILTERS ( 'bv_a2p'[montant_mouvement] < 0 ),
    KEEPFILTERS ( 'bv_a2p'[type_mouvement] = "VERSEMENT" )
)

Total retrait (fast) :=
CALCULATE (
    SUM ( 'bv_a2p'[montant_mouvement] ),
    KEEPFILTERS ( 'bv_a2p'[montant_mouvement] > 0 ),
    KEEPFILTERS ( 'bv_a2p'[type_mouvement] <> "RACHAT" )
)


Total Investi_10ans :=
VAR HasYearFilter = ISFILTERED ( 'Calendrier'[Année] )
VAR TodayDate     = TODAY()
VAR StartDate     = DATE ( YEAR ( TodayDate ) - 9, 1, 1 )
RETURN
IF (
    HasYearFilter,
    [Total versement (fast)],
    CALCULATE (
        [Total versement (fast)],
        REMOVEFILTERS ( 'Calendrier' ),
        'bv_a2p'[date_de_valorisation] >= StartDate,
        'bv_a2p'[date_de_valorisation] <= TodayDate
    )
)

***********

Total Retrait_10ans :=
VAR HasYearFilter = ISFILTERED ( 'Calendrier'[Année] )
VAR TodayDate     = TODAY()
VAR StartDate     = DATE ( YEAR ( TodayDate ) - 9, 1, 1 )
RETURN
IF (
    HasYearFilter,
    [Total retrait (fast)],
    CALCULATE (
        [Total retrait (fast)],
        REMOVEFILTERS ( 'Calendrier' ),
        'bv_a2p'[date_de_valorisation] >= StartDate,
        'bv_a2p'[date_de_valorisation] <= TodayDate
    )
)





PM_FIN_ANNEE_10Y_DEFAULT :=
VAR HasYearFilter = ISFILTERED('Calendrier'[Année])

/* borne max réelle dans les données */
VAR DataMaxDate =
    CALCULATE ( MAX ( 'bv_a2p'[date_de_valorisation] ), REMOVEFILTERS('Calendrier') )
VAR DataMaxYear = YEAR ( DataMaxDate )

/* TABLE des années sélectionnées (si filtre posé) */
VAR _sel =
    SELECTCOLUMNS( VALUES('Calendrier'[Année]), "Y", 'Calendrier'[Année] )

/* TABLE par défaut = 10 dernières années jusqu'à DataMaxYear */
VAR _def =
    CALCULATETABLE(
        SELECTCOLUMNS( VALUES('Calendrier'[Année]), "Y", 'Calendrier'[Année] ),
        FILTER( ALL('Calendrier'[Année]),
            'Calendrier'[Année] >= DataMaxYear - 9 &&
            'Calendrier'[Année] <= DataMaxYear
        )
    )

/* Choix de la table, sans IF-table */
VAR YearsToScan =
    UNION(
        FILTER( _sel, HasYearFilter ),          /* garde _sel si filtre actif, vide sinon */
        FILTER( _def, NOT HasYearFilter )       /* garde _def si pas de filtre, vide sinon */
    )

/* Itération année par année */
VAR Result =
    SUMX(
        YearsToScan,
        VAR Y = [Y]
        VAR TargetDate =
            IF(
                Y < DataMaxYear,
                DATE(Y,12,31),
                CALCULATE(
                    MAX('bv_a2p'[date_de_valorisation]),
                    REMOVEFILTERS('Calendrier'[Date]),
                    YEAR('bv_a2p'[date_de_valorisation]) = Y
                )
            )
        RETURN
            IF(
                NOT ISBLANK(TargetDate),
                CALCULATE(
                    SUM('bv_a2p'[montant_mouvement]),
                    IF(
                        Y < DataMaxYear,
                        'bv_a2p'[type_mouvement] = "PM FIN ANNEE",
                        'bv_a2p'[type_mouvement] IN { "PM FIN ANNEE", "PM" }
                    ),
                    REMOVEFILTERS('Calendrier'[Date]),
                    TREATAS( { TargetDate }, 'Calendrier'[Date] )
                )
            )
    )
RETURN Result


PM_FIN_ANNEE = 
VAR HasYearFilter =
   ISFILTERED ( 'Calendrier'[Année] )
/* Année cible :
  - si filtre actif : année max sélectionnée
  - sinon : dernière année (pour le contrat courant) où il existe une PM FIN D'ANNEE
*/
VAR TargetYear =
   IF (
       HasYearFilter,
       MAX ( 'Calendrier'[Année] ),
       CALCULATE (
           MAXX (
               FILTER ( 'bv_a2p', 'bv_a2p'[type_mouvement] = "PM FIN ANNEE" ),
               YEAR ( 'bv_a2p'[date_de_valorisation] )
           ),
           REMOVEFILTERS ( 'Calendrier' )   -- on ignore le slicer Année s'il n'est pas utilisé
       )
   )
VAR EndDate = DATE ( TargetYear, 12, 31 )
RETURN
CALCULATE (
   SUM ( 'bv_a2p'[montant_mouvement] ),
   'bv_a2p'[type_mouvement] = "PM FIN ANNEE",
   /* force uniquement le 31/12 de l'année retenue */
   REMOVEFILTERS ( 'Calendrier'[Date] ),
   TREATAS ( { EndDate }, 'Calendrier'[Date] )
)








Première mesure :
Total Investi_10ans = 
-SUMX ( 
    FILTER('bv_a2p',
    ('bv_a2p'[montant_mouvement] < 0 
    && bv_a2p[type_mouvement] <> "PM FIN D'ANNEE" )
    )
     , 'bv_a2p'[montant_mouvement] )
#####################################
     deuxième mesure :
     Total Retrait_10 ans = 
 SUMX (
     FILTER
     ('bv_a2p',
      'bv_a2p'[montant_mouvement] > 0
      && bv_a2p[type_mouvement] <> "PM FIN D'ANNEE")
      , 'bv_a2p'[montant_mouvement] )
#################################################################
      Troisièpme mesure : 
      PM_DEBUT_ANNEE_BIS = 
VAR HasYearFilter   = ISFILTERED ( 'Calendrier'[Année] )
VAR SelectedMinYear = IF ( HasYearFilter, MIN ( 'Calendrier'[Année] ) )
/* Année de début réelle du contrat dans le contexte courant */
VAR ContractStartYear =
   CALCULATE (
       MINX (
           FILTER ( ALL ( 'bv_a2p' ),
               'bv_a2p'[type_mouvement] = "PM DEBUT ANNEE"
           ),
           YEAR ( 'bv_a2p'[date_de_valorisation] )
       ),
       /* on garde le contexte contrat, remplace par la dim contrat si tu l’as */
       ALLEXCEPT ( 'bv_a2p', 'bv_a2p'[numero_contrat] )
   )
/* Si filtre d'années → on prend le plus tardif des deux.
  Sinon → on prend l’année de début réelle du contrat. */
VAR TargetYear =
   IF ( HasYearFilter,
        MAX ( SelectedMinYear, ContractStartYear ),
        ContractStartYear
   )
VAR EndDate = DATE ( TargetYear, 1, 1 )        -- PM début = 01/01/TargetYear
RETURN
-CALCULATE (
   SUM ( 'bv_a2p'[montant_mouvement] ),
   'bv_a2p'[type_mouvement] = "PM DEBUT ANNEE",
   /* on isole la date cible, on neutralise le slicer Calendrier */
   REMOVEFILTERS ( 'Calendrier'[Date] ),
   TREATAS ( { EndDate }, 'Calendrier'[Date] )
)
Quatrième mesure ; 
PM_FIN_ANNEE = 
VAR HasYearFilter =
   ISFILTERED ( 'Calendrier'[Année] )
/* Année cible :
  - si filtre actif : année max sélectionnée
  - sinon : dernière année (pour le contrat courant) où il existe une PM FIN D'ANNEE
*/
VAR TargetYear =
   IF (
       HasYearFilter,
       MAX ( 'Calendrier'[Année] ),
       CALCULATE (
           MAXX (
               FILTER ( 'bv_a2p', 'bv_a2p'[type_mouvement] = "PM FIN ANNEE" ),
               YEAR ( 'bv_a2p'[date_de_valorisation] )
    
           ),
           REMOVEFILTERS ( 'Calendrier' )   -- on ignore le slicer Année s'il n'est pas utilisé
       )
   )
VAR EndDate = DATE ( TargetYear, 12, 31 )
RETURN
CALCULATE (
   SUM ( 'bv_a2p'[montant_mouvement] ),
   'bv_a2p'[type_mouvement] = "PM FIN ANNEE",
   /* force uniquement le 31/12 de l'année retenue */
   REMOVEFILTERS ( 'Calendrier'[Date] ),
   TREATAS ( { EndDate }, 'Calendrier'[Date] )
)

##################
Cinquième mesure  :
TRI % = 

CALCULATE(
    XIRR(
        'bv_a2p',
        'bv_a2p'[montant_mouvement],
        'bv_a2p'[date_de_valorisation],,BLANK()
    )
)
